1 -  npm install -g @angular/cli устанавливаем ангулар кли глобально
2 - ng new my-first-project генерируем наш проект

Компоненты - ручной режим
1 - создаем каталог для компонента (например post)
2 - создаем файл компонента post.component.ts (главный файл)
  - импортируем Component декоратор из @angular/core
  - всё является классами поэтому экспортируем класс PostComponent
  - объявляем декоратор @Component для нашего класса и передаем туда объект опций:
    - selector: 'app-post'
    - templateUrl: './post.component.html'
  - нам ts подсказывает что наш компонент не объявлен в app.module. Объявляем его в declarations
  - теперь мы можем вывести наш компонент в шаблоне app.component.html тегом <app-post></app-post>
3 - создаем файл шаблона компонента post.component.html
4 - (не обязательно) создаем файл стилей компонента post.component.scss
  - подключаем стили в post.component.ts в декораторе @Component передавая в параметры:
    - styleUrls: ['./post.component.scss'],

Компоненты - cli
1 - ng g(generate) c(component) post --skipTests
  - ангулар автоматически создает и импортирует компонент и сбрасывает тесты

Свои настройки компонента
- вместо templateUrl в декоратор @Component можно передать свойство template
  куда передать разметку ввиде строки `<div>Component</div>`
- также можно передавать стили в свойство style и передать туда массив строк
  [`.post4 {padding: 5rem;}`]

Передача параметров в компоненты
- для передачи параметров в компонент используем одностороннюю связку куда передаем данные
  <app-post [post]="post"></app-post>
- чтобы принять данные в компоненте необходимо создать в классе компонента переменную и применить к ней
  декоратор @Input который импонтируется из @angular/core
   @Input() post; обозначаем что будет передан параметр
- далее выводим в шаблоне в интерполяции поля данного параметра {{post.title}}
- можно переопределять название ожидаемого принимаего параметра в компоненте
  <app-post [MyPost]="item"></app-post>
  @Input('MyPost') post; таким образом переменная post получит значение параметра MyPost
  иначе если не передаем в декоратор никаких параметров он будет ждать переменную с именем параметра

Передача дочерних элементов в компонент
- Можно писать компонент не как пустой тег а как тег обертку для контента
  <app-post [post]="p"><small *ngIf="p.text.length > 10">Long post</small></app-post>
- получить в компоненте дочерние элементы можно с помощью специального тега <ng-content></ng-content>
  <div class="card"><ng-content></ng-content></div>
- если нам надо будет иметь доступ до дочерних элементов в компоненте обертке то даем ему референцию
  <app-post [post]="p"><small #longPost>Long post</small></app-post>
- затем внутри компонента обертки получаем доступ используя декоратор @ContentChild
  @ContentChild('longPost', {static: true}) longPostRef: ElementRef;
  Тут установили static: true так как к примеру хотим использовать элемент в ngOnInit

Передача параметров из компонента
- обязательно импортируем FormsModule из @angular/forms в app.module
  imports: [FormsModule]
- в классе где задействована форма и надо передать данные в родительский компонент (emit) импортируем
  декоратор @Output из @angular/core и указываем название метода отдаваемого наружу
  @Output() onAdd: EventEmitter<IPost> = new EventEmitter<IPost>();
- далее там же в классе применяем этот метод в нужный момент (создание поста к примеру)
  this.onAdd.emit(post); метод emit добавляет декоратор @Output
- далее в родительском компоненте где объявляем наш дочерний компонент добавляем прослушку события onAdd
  <app-post-form (onAdd)="addPost($event)"></app-post-form>
- там же в родителе в классе создаем метод для работы с переданными от потомка данными
  addPost(post: IPost) {...} куда получаем эвент и им распоряжаемся

Жизненный цикл компонентов https://angular.io/guide/lifecycle-hooks
- implements для тайпскрипта, работает и без него
- constructor - не хук но отрабатывает первым до хуков
1 - ngOnChanges - при изменении параметров, возвращает текущее и предыдущее значение параметров (до инициализации)
  ngOnChanges(changes: SimpleChanges): void
2 - ngOnInit - инициализация компонента
3 - ngDoCheck - начало действий во время изменений, делаются проверки, вызывается при каждом изменении
4 - ngAfterContentInit - вызывается при инициализации дочернего контента (внутри компонента обертки)
5 - ngAfterContentChecked - вызывается когда весь передаваемый контент готов для использования
6 - ngAfterViewInit - вызывается при инициализации элементов компонента
7 - ngAfterViewChecked - вызывается при проверке элементов компонента
8 - ngOnDestroy - вызывается при уничтожении компонента

Стратегия изменений компонента
- Компоненту можно задавать стратегию отслеживания изменений. Задается это в декораторе @Component
  changeDetection: ChangeDetectionStrategy.Default - по умолчанию
  По умолчанию отслеживается каждое изменение элементов и происходит перерисовка
- Можно задать стратегию .OnPush и тогда ангулар будет реагировать только на входные свойства @Input

Стили с ViewEncapsulation
- Стили объявленные внутри стилевого файла компонента доступны только для данного компонента так как к ним
  добавляется дата параметр к которому стиль привязывается
- Подобное поведение можно изменить добавив в декоратора компонента параметр:
  encapsulation: ViewEncapsulation.None

-----------------------------

Динамические данные
1 - динамика заводится внутри классов, создаем переменную в классе:
  - title = 'Post component';
2 - выводим переменные в шаблоне с помощью интерполяции {{}} - для примитивов
  - <h1>{{title}}</h1>
3 - можно выполнять простые взаимодействия которые можно привести к строке
  - {{2+1}} // 3, {{'string' + ' js'}} // string js, {{[1,2,3]}} // 1,2,3

-----------------------------

Binding - привязка данных
1 - для односторонней связки html с ts оборачиваем свойство в [] скобки. Например <img [src]='img'/>
  и передаем туда переменную
2 - для event binding односторонней связки ts с html оборачиваем события в () скобки, указываем метод и передаем event
  <input type="text" (keyup.enter)="onInput($event)">
  onInput(e: KeyboardEvent) {this.val = (<HTMLInputElement>e.target).value}
3 - создаем локальную ссылку для элемента и далее получаем к нему доступ и можем передать эвент таким образом
  <input (blur)="onBlur(myInput.value)" #myInput>
  onBlur(str: string) {this.val = str}
4 - way binding двухстороннее связывание ts с html
  - создаем переменную с каким то начальным значением например value и байндим в элемент
    <input type="text" [value]="value">
  - добавляем байндинг события
    <input type="text" [value]="value" (input)="onInput($event)">
5 - связывание с помощью ngModel
  - импортируем в модуль (app.module.ts например) FormsModule
  - <input type="text" [(ngModel)]="value"> теперь value меняется при динамическом вводе текста
6 - если функция состоит из одной строки то можно ее объявить прямо в эвенте
  - <button (click)="imgStyles = {width: '300px', height: '300px'}">big</button>

------------------------------

Директивы - вспомогательные атрибуты для управления хтмл элепентов и компонентов
1 - ngStyle
  - при добавлении к элементу мы байндим ngStyle
    <div [ngStyle]="{width: '200px', borderRadius: '5px'}"></div>
2 - ngClass
  - <div [ngClass]="{active: title === 'active', hidden: !title}"></div>
  - <div [class.active]="title === 'active'" [class.hidden]="!title"></div>
3 - ngIf else - структурные
  - <div *ngIf="title === 'active'"></div> - одно условие
  - <div *ngIf="title === 'active'; else emptyText"></div> - условие с иначе
    <ng-template><div #emptyText>Пусто</div></ng-template> - контейнер для иначе
4 - ngSwitch
  - <div [ngSwitch]="title">
      <p *ngSwitchCase="'active'">case 1</p>
      <p *ngSwitchCase="'not active'">case 2</p>
      <p *ngSwitchDefault>case 3</p>
    </div>
5 - ngFor
  - <p *ngFor="let item of arrItems">{{item}}</p>
  - <p *ngFor="let item of arrItems; let idx = index">{{idx}}-{{item}}</p> - итерация с индексом

------------------------------

Пайпы - трансформеры для изменения отображения данных
  - {{ myDate | date:'small' | lowercase }}

------------------------------

Референции
- Для доступа к любому элементу необходимо задать элементу референцию с помощью #
  <input type="text" #myInput>
- в классе компонента импортируем декоратор @ViewChild и применяем его к переменной куда сложим референцию
  @ViewChild('titleInput', {static: false}) titleInputRef: ElementRef;
- первым параметром в декоратор передадим имя референции,
  вторым объект со значением static: false (если хотим обратиться в ngOnInit хуке то передаем true до 9 версии)
- применяем нашу референцию например для получения фокуса на элементе при нажатии кнопки
  setFocus() { this.titleInputRef.nativeElement.focus(); }
  доступ идет через nativeElement, делается это для универсальности (мы работаем еще и с мобилками)

3. Компоненты в деталях / 8
