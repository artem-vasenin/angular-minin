1 -  npm install -g @angular/cli устанавливаем ангулар кли глобально
2 - ng new my-first-project генерируем наш проект

Компоненты - ручной режим
1 - создаем каталог для компонента (например post)
2 - создаем файл компонента post.component.ts (главный файл)
  - импортируем Component декоратор из @angular/core
  - всё является классами поэтому экспортируем класс PostComponent
  - объявляем декоратор @Component для нашего класса и передаем туда объект опций:
    - selector: 'app-post'
    - templateUrl: './post.component.html'
  - нам ts подсказывает что наш компонент не объявлен в app.module. Объявляем его в declarations
  - теперь мы можем вывести наш компонент в шаблоне app.component.html тегом <app-post></app-post>
3 - создаем файл шаблона компонента post.component.html
4 - (не обязательно) создаем файл стилей компонента post.component.scss
  - подключаем стили в post.component.ts в декораторе @Component передавая в параметры:
    - styleUrls: ['./post.component.scss'],

Компоненты - cli
1 - ng g(generate) c(component) post --skipTests
  - ангулар автоматически создает и импортирует компонент и сбрасывает тесты

Свои настройки компонента
- вместо templateUrl в декоратор @Component можно передать свойство template
  куда передать разметку ввиде строки `<div>Component</div>`
- также можно передавать стили в свойство style и передать туда массив строк
  [`.post4 {padding: 5rem;}`]

Передача параметров в компоненты
- для передачи параметров в компонент используем одностороннюю связку куда передаем данные
  <app-post [post]="post"></app-post>
- чтобы принять данные в компоненте необходимо создать в классе компонента переменную и применить к ней
  декоратор @Input который импонтируется из @angular/core
   @Input() post; обозначаем что будет передан параметр
- далее выводим в шаблоне в интерполяции поля данного параметра {{post.title}}
- можно переопределять название ожидаемого принимаего параметра в компоненте
  <app-post [MyPost]="item"></app-post>
  @Input('MyPost') post; таким образом переменная post получит значение параметра MyPost
  иначе если не передаем в декоратор никаких параметров он будет ждать переменную с именем параметра

Передача дочерних элементов в компонент
- Можно писать компонент не как пустой тег а как тег обертку для контента
  <app-post [post]="p"><small *ngIf="p.text.length > 10">Long post</small></app-post>
- получить в компоненте дочерние элементы можно с помощью специального тега <ng-content></ng-content>
  <div class="card"><ng-content></ng-content></div>
- если нам надо будет иметь доступ до дочерних элементов в компоненте обертке то даем ему референцию
  <app-post [post]="p"><small #longPost>Long post</small></app-post>
- затем внутри компонента обертки получаем доступ используя декоратор @ContentChild
  @ContentChild('longPost', {static: true}) longPostRef: ElementRef;
  Тут установили static: true так как к примеру хотим использовать элемент в ngOnInit

Передача параметров из компонента
- обязательно импортируем FormsModule из @angular/forms в app.module
  imports: [FormsModule]
- в классе где задействована форма и надо передать данные в родительский компонент (emit) импортируем
  декоратор @Output из @angular/core и указываем название метода отдаваемого наружу
  @Output() onAdd: EventEmitter<IPost> = new EventEmitter<IPost>();
- далее там же в классе применяем этот метод в нужный момент (создание поста к примеру)
  this.onAdd.emit(post); метод emit добавляет декоратор @Output
- далее в родительском компоненте где объявляем наш дочерний компонент добавляем прослушку события onAdd
  <app-post-form (onAdd)="addPost($event)"></app-post-form>
- там же в родителе в классе создаем метод для работы с переданными от потомка данными
  addPost(post: IPost) {...} куда получаем эвент и им распоряжаемся

Жизненный цикл компонентов https://angular.io/guide/lifecycle-hooks
- implements для тайпскрипта, работает и без него
- constructor - не хук но отрабатывает первым до хуков
1 - ngOnChanges - при изменении параметров, возвращает текущее и предыдущее значение параметров (до инициализации)
  ngOnChanges(changes: SimpleChanges): void
2 - ngOnInit - инициализация компонента
3 - ngDoCheck - начало действий во время изменений, делаются проверки, вызывается при каждом изменении
4 - ngAfterContentInit - вызывается при инициализации дочернего контента (внутри компонента обертки)
5 - ngAfterContentChecked - вызывается когда весь передаваемый контент готов для использования
6 - ngAfterViewInit - вызывается при инициализации элементов компонента
7 - ngAfterViewChecked - вызывается при проверке элементов компонента
8 - ngOnDestroy - вызывается при уничтожении компонента

Стратегия изменений компонента
- Компоненту можно задавать стратегию отслеживания изменений. Задается это в декораторе @Component
  changeDetection: ChangeDetectionStrategy.Default - по умолчанию
  По умолчанию отслеживается каждое изменение элементов и происходит перерисовка
- Можно задать стратегию .OnPush и тогда ангулар будет реагировать только на входные свойства @Input

Стили с ViewEncapsulation
- Стили объявленные внутри стилевого файла компонента доступны только для данного компонента так как к ним
  добавляется дата параметр к которому стиль привязывается
- Подобное поведение можно изменить добавив в декоратора компонента параметр:
  encapsulation: ViewEncapsulation.None

-----------------------------

Динамические данные
1 - динамика заводится внутри классов, создаем переменную в классе:
  - title = 'Post component';
2 - выводим переменные в шаблоне с помощью интерполяции {{}} - для примитивов
  - <h1>{{title}}</h1>
3 - можно выполнять простые взаимодействия которые можно привести к строке
  - {{2+1}} // 3, {{'string' + ' js'}} // string js, {{[1,2,3]}} // 1,2,3

-----------------------------

Binding - привязка данных
1 - для односторонней связки html с ts оборачиваем свойство в [] скобки. Например <img [src]='img'/>
  и передаем туда переменную
2 - для event binding односторонней связки ts с html оборачиваем события в () скобки, указываем метод и передаем event
  <input type="text" (keyup.enter)="onInput($event)">
  onInput(e: KeyboardEvent) {this.val = (<HTMLInputElement>e.target).value}
3 - создаем локальную ссылку для элемента и далее получаем к нему доступ и можем передать эвент таким образом
  <input (blur)="onBlur(myInput.value)" #myInput>
  onBlur(str: string) {this.val = str}
4 - way binding двухстороннее связывание ts с html
  - создаем переменную с каким то начальным значением например value и байндим в элемент
    <input type="text" [value]="value">
  - добавляем байндинг события
    <input type="text" [value]="value" (input)="onInput($event)">
5 - связывание с помощью ngModel
  - импортируем в модуль (app.module.ts например) FormsModule
  - <input type="text" [(ngModel)]="value"> теперь value меняется при динамическом вводе текста
6 - если функция состоит из одной строки то можно ее объявить прямо в эвенте
  - <button (click)="imgStyles = {width: '300px', height: '300px'}">big</button>

------------------------------

Директивы - вспомогательные атрибуты для управления хтмл элепентов и компонентов (атрибутные и структурные)
1 - ngStyle
  - при добавлении к элементу мы байндим ngStyle
    <div [ngStyle]="{width: '200px', borderRadius: '5px'}"></div>
2 - ngClass
  - <div [ngClass]="{active: title === 'active', hidden: !title}"></div>
  - <div [class.active]="title === 'active'" [class.hidden]="!title"></div>
3 - ngIf else - структурные
  - <div *ngIf="title === 'active'"></div> - одно условие
  - <div *ngIf="title === 'active'; else emptyText"></div> - условие с иначе
    <ng-template><div #emptyText>Пусто</div></ng-template> - контейнер для иначе
4 - ngSwitch
  - <div [ngSwitch]="title">
      <p *ngSwitchCase="'active'">case 1</p>
      <p *ngSwitchCase="'not active'">case 2</p>
      <p *ngSwitchDefault>case 3</p>
    </div>
5 - ngFor
  - <p *ngFor="let item of arrItems">{{item}}</p>
  - <p *ngFor="let item of arrItems; let idx = index">{{idx}}-{{item}}</p> - итерация с индексом

Создание своих директив
1 - Создаем файл для директивы myDir.directive.ts и экспортируем класс
  StyleDirective к которому применяем декоратор @Directive
2 - В декоратор передаем объект с параметром selector и присваеваем ему
  значение имени директивы selector: '[myDir]' в скобках
3 - Импортируем директиву в модуле в массиве declarations
4 - ng g d directives/myDir --skipTests - автоматическая генерация директивы
5 - Чтобы получить доступ до элемента который вызвал директиву делаем инъекцию
  constructor(private elRef: ElementRef) {elRef.nativeElement.style.color = 'green';}
  и описываем нужное нам изменение объекта, это будет работать в вебе но...
  - для универсальности работы с мобилками надо подключить Renderer2 из @angular/core
  constructor(private elRef: ElementRef, private renderer: Renderer2) {
    this.renderer.setStyle(this.elRef.nativeElement, 'color', 'green');
  }
6 - Затем применяем директиву в шаблоне <span myDir>Some text</span>

Добавление событий
- добавляем декоратор @HostListener куда передаем имя события, эвент и метод который отработает
  @HostListener('click', ['$event']) onClick(event: Event) {
    this.elRef.nativeElement.style.color = 'red'; } // и при клике сменится цвет

Передача параметров в директиву
- если мы хотим передавать в директиву какие то параметры <span myDir="red">Some text</span> то
- необходимо импортировать в директиву декоратор @Input и применить его на входящие параметры
  @Input('appStyle') color: string = 'orange'; // по умолчанию оранж, это вариант получения
  this.renderer.setStyle(this.elRef.nativeElement, 'color', this.color); // в хостЛистенере пишем наше свойство цвета
- также можно используя директиву на элементе передавать ему и другие параметры и принять их в директиве
  <span myDir="red" fontWeight="bold">Some text</span>
  @Input('appStyle') fontWeight: string = 'normal';
  this.renderer.setStyle(this.elRef.nativeElement, 'fontWeight', this.fontWeight); // добавляем стиль
- можно передать мобъект стилей а не поштучно, тогда свойство надо забайндить
  [dStyles]="{textDecoration: 'underline', textTransform: 'uppercase'}"
  @Input() dStyles: {textDecoration?: string, textTransform?: string}; // разрешаем некоторые стили

Декоратор @HostBinding
- можно добавлять стили без референции элемента, просто применяем декоратор @HostBinding
  @HostBinding('style.backgroundColor') bg = null;
- и далее просто меняем значение переменной bg передавая туда данные из свойств
  this.bg = this.dStyles.bg;

Структурные директивы
- звездочка перед структурной директивой лишь обозначает что элемент будет завернут в ng-template а само
  условие например будет передано именно в него типа данного примера:
  <p *ngIf="show">some</p> поменяется на такой вид:
  <ng-template [ngIf]="show"><p>some</p></ng-template>
1 - создаем свою структурную директиву: ng g d ifnot --skipTests
2 - инжектируем в конструктор директивы из @angular/core две сущности:
  constructor(private templateRef: TemplateRef<any>, private viewContainer: ViewContainerRef){...}
  - TemplateRef - указывает на содержимое будущего ng-template (элементы подвергаемые условию)
  - ViewContainerRef - указывает на сам контейнер ng-template куда завернётся содержимое
3 - принимаем с помощью декоратора @Input параметром метод который примет в свою очередь параметр,
  который мы передадим в директиву (условие)
  @Input() set ifNot(condition: boolean) { condition
    ? this.viewContainer.createEmbeddedView(this.templateRef) // если попали, то заварачиваем в контейнер
    : this.viewContainer.clear()} // если не папали то очищаем контейнер

------------------------------

Пайпы - трансформеры для изменения отображения данных https://angular.io/api?type=pipe
Встроенные пайпы (сущности модуля BrowserModule поэтому они импортируются вместе с ним)
1 - Работа с числами (Math.E) // 2.718281828459045
  {{Math.E | number}} // 2.718
  {{Math.E | number:'3.1-5' }} // 002.71828 - 1 цифра это числа до запятой, 2 значение диап от 1 до 5 с округл
  {{Math.E | number:'1.0-0' }} //3 - 1 цифра до запятой и без дробных чисел потому округляется до 3-х
2 - Работа со строками
  {{'hello' | uppercase | lowercase}} // сначала в HELLO а потом hello приведет в нижний регистр
  {{'hello' | titlecase | slice:1:3}} // сначала Hello а потом ell так как вырежим со 2 по 4 буквы
3 - Работа с датой (date = new Date()) // Tue Jun 09 2020 14:57:13 GMT+0300 (Москва, стандартное время)
  https://angular.io/api/common/DatePipe - слишком дохера настреок
  {{ value_expression | date [ : format [ : timezone [ : locale ] ] ] }}
  value_expression - наша дата
  date - сам пайп а далее разные параметры к нему которые можно передавать
  {{date | date}} // Jun 9, 2020
  {{date | date:'fullDate'}} // Tuesday, June 9, 2020 эквивалент
  {{date | date:'EEEE, MMMM d, y'}} // Tuesday, June 9, 2020
4 - Ещё
  {{0.42 | currency}} // $0.42
  {{0.42 | percent}} // 0.42% (можно с параметрами свойственными number)
  {{{a: 1, b: {c: 3}} | json}} // {'a': 1, 'b': {'c': 3}}

Создание пайпов вручную
1 - создаем файл my-pipe.pipe.ts и экспортируем класс пайпа и применяем к нему декоратор @Pipe
  @Pipe({name: 'mypipe'})
2 - регистрируем пайп в модуле в поле declarations
3 - имплементируемся от интерфейса PipeTransform который обязует реализовать метод transform
  transform(value: any, ...args: any): any {...} - принимает и трансформирует полученные данные
4 - ng g p my-mult --skipTests автоматическая генерация

Оптимизация пайпов
У пайпов по умолчанию есть параметра pure который говорит чтобы пайп отрабатыввал если изменилось что то во
входящем значении в метод трансформ. Это можно изменить добавив в декоратор @Pipe свойство pure: false

Асинхронные пайпы
- Если у нас есть асинхронные данные возвращаемые промисом, мы можем использовать пайп async который
вернет данные которые мы передаём в метод resolve отработоашего промиса
  prom: Promise<string> = new Promise<string>(resolve => {
      setTimeout(() => resolve('promise finish'), 4000);
    });
  <p>Wait for async... {{prom | async}}</p> // Wait for async... и через 4с promise finish
- Также если у нас есть Observable данные которые требуют подписки на стрим мы можем вернуть данные
  с помощью пайпа async
  date: Observable<Date> = new Observable<Date>(obs => {
    setInterval(() => obs.next(new Date()), 1000);
  });
  <p>Date: {{date | async | date:'mediumTime'}}</p>

------------------------------

Референции
- Для доступа к любому элементу необходимо задать элементу референцию с помощью #
  <input type="text" #myInput>
- в классе компонента импортируем декоратор @ViewChild и применяем его к переменной куда сложим референцию
  @ViewChild('titleInput', {static: false}) titleInputRef: ElementRef;
- первым параметром в декоратор передадим имя референции,
  вторым объект со значением static: false (если хотим обратиться в ngOnInit хуке то передаем true до 9 версии)
- применяем нашу референцию например для получения фокуса на элементе при нажатии кнопки
  setFocus() { this.titleInputRef.nativeElement.focus(); }
  доступ идет через nativeElement, делается это для универсальности (мы работаем еще и с мобилками)

------------------------------

RxJs - библиотека для работы с разными типами данных, событий, объектов и т.д. Удобно работает с асинхронными
данными. Удобно тем, что можно данные обернуть в стрим и в другом месте на них подписаться
- Импорты берутся из 2 библиотек. Из rxjs и rxjs/operators
  rxjs - для элементов создающих новые стримы
  rxjs/operators - относится к операторам
- const intervalStream$ = interval(1000) - вернет стрим объект (реактивные переменные помечаем $)
  который содержит метод subscribe принимающий в себя КБ ф-цию которая принимает некоторое значение
- с помощью subscribe мы можем подписываться на изменения происходящие в стриме и взаимодействовать с ними

Оптимизация стримов
- подписки на стримы необходимо прекращать для предотвращения утечки памяти
- для этого создаем переменную напрмиер sub: Subscription и в нее записываем результат работы subscribe
  sub: Subscription - переменная будет отвечать за подписку
  this.sub = intervalStreams$.subscribe(val => console.log(val))
  stop() {this.sub.unsubscribe()} - теперь мы можем отписаться от подписки на событие в каком либо методе

Операторы RxJS https://rxjs-dev.firebaseapp.com/guide/operators
- у стримов имеется метод pipe позволяющий применять операторы и их множество
- import {map, filter} from 'rxjs/operators' импортируем пару операторов
- теперь в pipe передаем эти операторы
  this.sub = intervalStreams$
    .pipe(
      filter(val => val % 2 === 0), - по приколу фильтруем четные значения (методы через запятую применяем)
      map(val => `maped value: ${val}`), - по приколу преобразуем значение в строку
    )
    .subscribe(val => console.log(val))

Создание своего стрима
1 - import {Observable} from 'rxjs' - импортируем класс обсервер.
2 - создаем стрим как экземпляр класса Observable конструктор которого принимает КБ с параметром observer
  const stream$ = new Observable(observer => { setTimeout(() => observer.next('finish'), 5000); });
3 - теперь мы можем подписаться на созданный стрим
  this.sub = stream$.subscribe(val => console.log(val));
4 - мы можем выбросить ошибку при каких то условиях
  const stream$ = new Observable(observer => { setTimeout(() => observer.error('WRONG'), 2000); });
5 - мы можем завершить стрим вызовом метода complete
  const stream$ = new Observable(observer => { setTimeout(() => observer.complete(), 1000); });
6 - метод subscribe принимает 3 КБ
  this.sub = stream$.subscribe(
    val => console.log(val), // если все пошло как надо (обязательная)
    err => console.error(err), // если все пошло не так
    () => console.info('complete'), // если принудительно завершили (если не было никаких ошибок!)
  );

- метод next в обсервере равносилен методу resolve в промисе. Говорит об успехе
- метод error в обсервере равносилен reject в промисе и говорит о неудаче (прекращает работу стрима)

Subject - класс позволяющий осоздавать стримы, тут мы можем не только подписываться но и эмитить события
1 - import {Subject} from 'rxjs'
2 - stream$: Subject<void> = new Subject<void>; // создаем стрим с пустыми типами данных
3 - this.sub = stream$.subscribe(val => console.log(val)); // подписываемся на стрим
4 - создаем к примеру кнопку дёргающую метод next
  <button (click)="next()">Next</button>
5 - создаем метод для работы с событием кнопки где дергаем метод next для обсервера
  next() {this.sub.next()}

------------------------------------

Сервисы - отдельные классы позволяющие работать с данными

Создание сервиса
1 - создаем файл сервиса и экпортируем класс сервиса (можно без декораторов)
2 - регистрируем созданный сервис (можно несколькими способами)
  - providers [AppCounterService] - для сервисов
3 - далее инжектируем сервис в конструкторе нужного компонента где будем его использовать
  constructor(private appCounterService: AppCounterService) {...}
4 - после этого мы можем использовать данный сервис в шаблоне компонента



17. Бонус. Основы RxJS - !!!
6. Сервисы / 1
